# Istio Webhook Fix - Deployment Guide

## Changes Made

### 1. EKS Security Group Rule (CRITICAL)

**File**: `/Users/mbastakis/dev/work/aicc-group/infrastructure/iac/aws/eks/terraform/main.tf`

**Change**: Added webhook ingress security group rule

```hcl
webhook_ingress = {
  type                     = "ingress"
  from_port                = 443
  to_port                  = 65535
  protocol                 = "tcp"
  source_cluster_security_group = true
  description              = "Allow control plane to reach webhook services (Istio, cert-manager, etc.)"
}
```

**Commit**: `06dd6f4` - "Add webhook security group rule for EKS control plane"
**Status**: ✅ Pushed to main

### 2. istiod Topology Spread Constraints Fix

**File**: `/Users/mbastakis/dev/work/aicc-group/infrastructure/argocd/helm-charts/istiod-helm/dev-values.yaml`

**Change**: Added missing labelSelector

```yaml
topologySpreadConstraints:
- maxSkew: 1
  topologyKey: topology.kubernetes.io/zone
  whenUnsatisfiable: DoNotSchedule
  labelSelector:
    matchLabels:
      app: istiod
```

**Commit**: `f511a9d` - "Fix topology spread constraints labelSelector"
**Status**: ✅ Pushed to main

## Deployment Steps

### Step 1: Apply Terraform Changes (CRITICAL)

This fixes the webhook connectivity issue by allowing EKS control plane to reach istiod webhooks.

```bash
# Navigate to EKS terraform directory
cd /Users/mbastakis/dev/work/aicc-group/infrastructure/iac/aws/eks/terraform

# Initialize terraform (if needed)
export GITLAB_ACCESS_TOKEN=REDACTED_GITLAB_TOKEN
export TF_STATE_NAME=dev
terraform init \
    -backend-config="address=https://gitlab.devops.telekom.de/api/v4/projects/377761/terraform/state/$TF_STATE_NAME" \
    -backend-config="lock_address=https://gitlab.devops.telekom.de/api/v4/projects/377761/terraform/state/$TF_STATE_NAME/lock" \
    -backend-config="unlock_address=https://gitlab.devops.telekom.de/api/v4/projects/377761/terraform/state/$TF_STATE_NAME/lock" \
    -backend-config="username=michail.bastakis" \
    -backend-config="password=$GITLAB_ACCESS_TOKEN" \
    -backend-config="lock_method=POST" \
    -backend-config="unlock_method=DELETE" \
    -backend-config="retry_wait_min=5"

# Review the plan
terraform plan

# Expected output:
# ~ module.eks.module.eks.aws_security_group_rule.cluster["webhook_ingress"]
#   + New security group rule will be created

# Apply the change
terraform apply

# Confirm: yes
```

**Expected Result**:
- New security group rule created
- Control plane can now reach webhooks on ports 443-65535

### Step 2: Wait for ArgoCD Sync

The istiod topology fix will be automatically applied by ArgoCD.

```bash
# Watch ArgoCD sync istiod
kubectl get application istiod -n argocd -w

# Wait for: Synced / Healthy
```

### Step 3: Verify Webhook Connectivity

After terraform apply, the webhooks should immediately start working.

```bash
# Check istiod logs - webhook should become ready
kubectl logs -n istio-system deployment/istiod --tail=50 | grep validation

# You should see:
# "validationController: Validation webhook is now ready"
# (instead of "webhook is not ready, retry")
```

### Step 4: Verify Gateway Pod Creation

Once webhooks are working, gateway pods should be created successfully.

```bash
# Check if gateway pods are being created
kubectl get pods -n istio-ingress -w

# Expected: Pods should transition from ContainerCreating to Running
# NAME                                    READY   STATUS    RESTARTS   AGE
# istio-ingressgateway-xxxxx-yyyyy        1/1     Running   0          1m
# istio-ingressgateway-xxxxx-zzzzz        1/1     Running   0          1m
# istio-ingressgateway-xxxxx-aaaaa        1/1     Running   0          1m

# Check events - should NOT see webhook timeouts anymore
kubectl get events -n istio-ingress --sort-by='.lastTimestamp' | tail -10
```

### Step 5: Verify Complete Gateway Deployment

```bash
# Check deployment status
kubectl get deployment istio-ingressgateway -n istio-ingress

# Expected:
# NAME                   READY   UP-TO-DATE   AVAILABLE   AGE
# istio-ingressgateway   3/3     3            3           15m

# Verify gateway pods have correct image (not "auto")
kubectl get pods -n istio-ingress -o jsonpath='{.items[0].spec.containers[0].image}'

# Expected:
# dockerhub.devops.telekom.de/istio/proxyv2:1.26.3

# Check gateway service
kubectl get svc istio-ingressgateway -n istio-ingress

# Expected:
# NAME                   TYPE           CLUSTER-IP      EXTERNAL-IP                          PORT(S)
# istio-ingressgateway   LoadBalancer   10.100.xxx.xxx  xxx.elb.eu-central-1.amazonaws.com   15021:xxx/TCP,80:xxx/TCP,443:xxx/TCP

# Verify gateway CRD
kubectl get gateway -n istio-ingress main-gateway

# Expected:
# NAME           AGE
# main-gateway   1m
```

### Step 6: Test Injection in Application Namespace

Verify that sidecar injection also works in other namespaces:

```bash
# Create test pod in fiber-magenta-apprentice namespace
kubectl run nginx-test --image=nginx -n fiber-magenta-apprentice

# Check if sidecar was injected
kubectl get pod nginx-test -n fiber-magenta-apprentice -o jsonpath='{.spec.containers[*].name}'

# Expected: nginx istio-proxy (2 containers)

# Clean up
kubectl delete pod nginx-test -n fiber-magenta-apprentice
```

## Troubleshooting

### If Terraform Apply Fails

Check for errors in the plan output. Common issues:
- Insufficient IAM permissions
- Terraform state lock issues
- Invalid security group parameters

### If Webhooks Still Timeout

1. **Verify security group rule was created**:
   ```bash
   # Get cluster security group ID
   kubectl get cm -n kube-system aws-auth -o yaml | grep -A 5 "data:"

   # Check in AWS Console:
   # EC2 → Security Groups → Search for "aicc-dev-cluster-api"
   # Inbound rules should include webhook_ingress rule
   ```

2. **Check istiod pods are running**:
   ```bash
   kubectl get pods -n istio-system -l app=istiod

   # All should be Running 1/1
   ```

3. **Restart istiod if needed**:
   ```bash
   kubectl rollout restart deployment/istiod -n istio-system

   # Wait for pods to restart
   kubectl rollout status deployment/istiod -n istio-system
   ```

4. **Check network ACLs**:
   If security groups are correct but still failing, check VPC Network ACLs in AWS Console.

### If Gateway Pods Still Don't Create

1. **Check namespace label**:
   ```bash
   kubectl get namespace istio-ingress --show-labels | grep istio-injection

   # Should show: istio-injection=enabled
   ```

2. **Check webhook configuration**:
   ```bash
   kubectl get mutatingwebhookconfiguration istio-sidecar-injector -o yaml | grep failurePolicy

   # Should show: failurePolicy: Fail
   ```

3. **Force recreate deployment**:
   ```bash
   kubectl delete replicaset -n istio-ingress -l app=istio-ingressgateway

   # Deployment will recreate pods automatically
   ```

## Success Criteria

✅ **All must be true**:

1. Terraform apply succeeded without errors
2. istiod logs show "Validation webhook is now ready"
3. Gateway pods created successfully (3/3 Running)
4. Gateway pods using correct image (not "auto")
5. Gateway service has external LoadBalancer address
6. No webhook timeout errors in events
7. Test pod in application namespace gets sidecar injected

## Timeline Estimate

- **Terraform apply**: 2-5 minutes
- **istiod sync**: 1-2 minutes (automatic via ArgoCD)
- **Gateway pod creation**: 1-2 minutes
- **Total**: ~10 minutes

## Rollback Plan

If issues occur after deployment:

```bash
# Rollback terraform changes
cd /Users/mbastakis/dev/work/aicc-group/infrastructure/iac/aws/eks/terraform

# Revert to previous commit
git revert HEAD
git push

# Apply rollback
terraform apply

# This will remove the webhook security group rule
```

**Note**: Rollback will bring back the webhook timeout issue. Only rollback if the change causes other problems.

## Next Steps After Successful Deployment

1. ✅ Monitor gateway pods for 24 hours
2. ✅ Test application deployments with sidecar injection
3. ✅ Deploy test application through gateway
4. ✅ Verify mutual TLS (mTLS) is working
5. ✅ Update runbooks with this fix as reference

---

**Document Version**: 1.0
**Date**: October 21, 2025
**Status**: Ready for Deployment
**Estimated Duration**: 10 minutes
