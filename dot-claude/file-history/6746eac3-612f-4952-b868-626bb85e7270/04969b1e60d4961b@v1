package services

import (
	"context"
	"fmt"
	"log/slog"
	"strings"
	"time"

	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"

	"github.com/contiamo/apa/agent_gateway/pkg/config"
	"github.com/contiamo/apa/agent_gateway/pkg/kubernetes"
	"github.com/contiamo/apa/agent_gateway/pkg/models"
)

const (
	// staticServerPrefix is the prefix used for static MCP server IDs
	staticServerPrefix = "static-"
)

// mcpService implements the MCPService interface
type mcpService struct {
	k8sClient KubernetesClient
	config    *config.Config
	logger    *slog.Logger
}

// NewMCPService creates a new MCP service
func NewMCPService(k8sClient KubernetesClient, cfg *config.Config, logger *slog.Logger) MCPService {
	return &mcpService{
		k8sClient: k8sClient,
		config:    cfg,
		logger:    logger,
	}
}

// StartServer starts a new MCP server or returns existing one
func (s *mcpService) StartServer(ctx context.Context, req models.StartMCPRequest) (*models.MCPServerResponse, error) {
	// Validate MCP type exists in configuration
	mcpConfig, err := s.config.GetMCPServer(req.MCPType)
	if err != nil {
		return nil, fmt.Errorf("invalid MCP type: %w", err)
	}

	// Check if this is a static MCP server
	if mcpConfig.StaticURL != "" {
		s.logger.InfoContext(ctx, "Using static MCP server",
			slog.String("mcp_type", req.MCPType),
			slog.String("static_url", mcpConfig.StaticURL))

		// Use static ID format
		mcpID := staticServerPrefix + req.MCPType

		// Use default paths if not set
		mcpPath := mcpConfig.MCPPath
		if mcpPath == "" {
			mcpPath = "/mcp"
		}
		ssePath := mcpConfig.SSEPath
		if ssePath == "" {
			ssePath = "/sse"
		}

		return &models.MCPServerResponse{
			MCPId: mcpID,
			URLs: models.MCPURLs{
				Base: mcpConfig.StaticURL,
				MCP:  mcpConfig.StaticURL + mcpPath,
				SSE:  mcpConfig.StaticURL + ssePath,
			},
		}, nil
	}

	// Check if k8sClient is available for dynamic servers
	if s.k8sClient == nil {
		return nil, fmt.Errorf("Kubernetes client not available - cannot start dynamic MCP servers")
	}

	// Generate deterministic ID based on configuration for dynamic servers
	name := kubernetes.GenerateMCPServerIDWithConfig(req.ClientID, req.MCPType, req.AdditionalFlags, req.AdditionalEnv)
	namespace := s.config.Kubernetes.Namespace

	s.logger.InfoContext(ctx, "Starting MCP server",
		slog.String("name", name),
		slog.String("client_id", req.ClientID),
		slog.String("mcp_type", req.MCPType))

	// Check if server already exists
	existingServer, err := s.checkExistingServer(ctx, name, namespace)
	if err == nil && existingServer != nil {
		// Server exists and is healthy
		s.logger.InfoContext(ctx, "MCP server already exists and is healthy",
			slog.String("name", name),
			slog.String("status", string(existingServer.Status)))

		// Convert to response format
		baseURL := existingServer.URL
		mcpPath := mcpConfig.MCPPath
		if mcpPath == "" {
			mcpPath = "/mcp"
		}
		ssePath := mcpConfig.SSEPath
		if ssePath == "" {
			ssePath = "/sse"
		}

		return &models.MCPServerResponse{
			MCPId: existingServer.ID,
			URLs: models.MCPURLs{
				Base: baseURL,
				MCP:  baseURL + mcpPath,
				SSE:  baseURL + ssePath,
			},
		}, nil
	}

	// If server exists but is unhealthy, delete it first
	if existingServer != nil && existingServer.Status == models.MCPServerStatusFailed {
		s.logger.InfoContext(ctx, "Removing unhealthy MCP server",
			slog.String("name", name))
		if err := s.cleanup(ctx, name, namespace); err != nil {
			s.logger.ErrorContext(ctx, "Failed to cleanup unhealthy server",
				slog.String("name", name),
				slog.String("error", err.Error()))
		}
	}

	// Parse TTL configuration to determine whether to use Deployment or Job
	var ttlDuration time.Duration
	if s.config.MCPServerTTL != "" {
		var err error
		ttlDuration, err = time.ParseDuration(s.config.MCPServerTTL)
		if err != nil {
			return nil, fmt.Errorf("failed to parse mcp_server_ttl: %w", err)
		}
	}

	// Create either Deployment or Job based on TTL
	if ttlDuration > 0 {
		// Use Job with TTL
		s.logger.InfoContext(ctx, "Creating MCP server as Job with TTL",
			slog.String("name", name),
			slog.Duration("ttl", ttlDuration))

		job := kubernetes.BuildMCPJob(name, namespace, req.ClientID, req.MCPType, mcpConfig, ttlDuration, req.AdditionalFlags, req.AdditionalEnv)
		if err := s.k8sClient.CreateJob(ctx, job); err != nil {
			if !errors.IsAlreadyExists(err) {
				return nil, fmt.Errorf("failed to create job: %w", err)
			}
			// Job already exists, continue
			s.logger.InfoContext(ctx, "Job already exists", slog.String("name", name))
		}
	} else {
		// Use Deployment (no TTL)
		s.logger.InfoContext(ctx, "Creating MCP server as Deployment",
			slog.String("name", name))

		deployment := kubernetes.BuildMCPDeployment(name, namespace, req.ClientID, req.MCPType, mcpConfig, req.AdditionalFlags, req.AdditionalEnv)
		if err := s.k8sClient.CreateDeployment(ctx, deployment); err != nil {
			if !errors.IsAlreadyExists(err) {
				return nil, fmt.Errorf("failed to create deployment: %w", err)
			}
			// Deployment already exists, continue
			s.logger.InfoContext(ctx, "Deployment already exists", slog.String("name", name))
		}
	}

	svc := kubernetes.BuildMCPService(name, namespace, req.ClientID, req.MCPType, mcpConfig.Port)
	if err := s.k8sClient.CreateService(ctx, svc); err != nil {
		if !errors.IsAlreadyExists(err) {
			// Cleanup deployment/job if service creation fails
			if ttlDuration > 0 {
				_ = s.k8sClient.DeleteJob(ctx, name, namespace)
			} else {
				_ = s.k8sClient.DeleteDeployment(ctx, name, namespace)
			}
			return nil, fmt.Errorf("failed to create service: %w", err)
		}
		// Service already exists, continue
		s.logger.InfoContext(ctx, "Service already exists", slog.String("name", name))
	}

	// Build response
	baseURL := kubernetes.GetServiceURL(name, namespace, mcpConfig.Port)

	// Use default paths if not set
	mcpPath := mcpConfig.MCPPath
	if mcpPath == "" {
		mcpPath = "/mcp"
	}
	ssePath := mcpConfig.SSEPath
	if ssePath == "" {
		ssePath = "/sse"
	}

	response := &models.MCPServerResponse{
		MCPId: name,
		URLs: models.MCPURLs{
			Base: baseURL,
			MCP:  baseURL + mcpPath,
			SSE:  baseURL + ssePath,
		},
	}

	// Check if we should wait for the server to be ready
	// Default to true if not specified (backward compatibility)
	shouldWait := req.WaitForReady == nil || *req.WaitForReady

	if shouldWait {
		// Wait briefly for pod to become ready
		server := &models.MCPServer{
			ID:        name,
			ClientID:  req.ClientID,
			MCPType:   req.MCPType,
			URL:       baseURL,
			Status:    models.MCPServerStatusPending,
			CreatedAt: time.Now().UTC(),
			Message:   "MCP server is being created",
		}

		if readyServer := s.waitForReady(ctx, name, namespace, server); readyServer != nil {
			// Update response status based on ready server
			if readyServer.Status == models.MCPServerStatusRunning {
				return response, nil
			}
		}
	}

	return response, nil
}

// StopServer stops and removes an MCP server
func (s *mcpService) StopServer(ctx context.Context, id string) error {
	if isStaticServer(id) {
		s.logger.InfoContext(ctx, "Skip stopping static MCP server",
			slog.String("id", id))
		return nil
	}

	// Check if k8sClient is available for dynamic servers
	if s.k8sClient == nil {
		return fmt.Errorf("Kubernetes client not available - cannot stop dynamic MCP servers")
	}

	namespace := s.config.Kubernetes.Namespace

	s.logger.InfoContext(ctx, "Stopping MCP server",
		slog.String("id", id),
		slog.String("namespace", namespace))

	return s.cleanup(ctx, id, namespace)
}

// GetServer retrieves information about an MCP server
func (s *mcpService) GetServer(ctx context.Context, id string) (*models.MCPServer, error) {
	// Check if this is a static server
	if isStaticServer(id) {
		// Extract MCP type from ID (format: static-{mcp_type})
		mcpType := strings.TrimPrefix(id, staticServerPrefix)

		// Get configuration for this MCP type
		mcpConfig, err := s.config.GetMCPServer(mcpType)
		if err != nil {
			return nil, fmt.Errorf("MCP server not found: %s", id)
		}

		// Return static server information
		return &models.MCPServer{
			ID:        id,
			ClientID:  "static", // Static servers don't have client instance
			MCPType:   mcpType,
			URL:       mcpConfig.StaticURL,
			Status:    models.MCPServerStatusRunning, // Assume static servers are always running
			CreatedAt: time.Now().UTC(),              // Static servers don't have creation time
			Message:   "Static MCP server",
		}, nil
	}

	// Check if k8sClient is available for dynamic servers
	if s.k8sClient == nil {
		return nil, fmt.Errorf("Kubernetes client not available - cannot manage dynamic MCP servers")
	}

	namespace := s.config.Kubernetes.Namespace

	// Try to find the pod - it could be managed by a Deployment or Job
	var pod *corev1.Pod
	var createdAt time.Time

	// First, try to get deployment
	deployment, err := s.k8sClient.GetDeployment(ctx, id, namespace)
	if err == nil {
		// Found deployment - get its pods
		pods, err := s.k8sClient.ListPods(ctx, namespace, map[string]string{"apa.io/mcp-server-id": id})
		if err != nil {
			return nil, fmt.Errorf("failed to list pods for deployment: %w", err)
		}
		if len(pods) == 0 {
			return nil, fmt.Errorf("no pods found for MCP server: %s", id)
		}
		pod = pods[0] // Take the first pod
		createdAt = deployment.CreationTimestamp.Time
	} else if errors.IsNotFound(err) {
		// Not a deployment, try job
		job, err := s.k8sClient.GetJob(ctx, id, namespace)
		if err == nil {
			// Found job - get its pods
			pods, err := s.k8sClient.ListPods(ctx, namespace, map[string]string{"apa.io/mcp-server-id": id})
			if err != nil {
				return nil, fmt.Errorf("failed to list pods for job: %w", err)
			}
			if len(pods) == 0 {
				return nil, fmt.Errorf("no pods found for MCP server: %s", id)
			}
			pod = pods[0] // Take the first pod
			createdAt = job.CreationTimestamp.Time
		} else if errors.IsNotFound(err) {
			return nil, fmt.Errorf("MCP server not found: %s", id)
		} else {
			return nil, fmt.Errorf("failed to get job: %w", err)
		}
	} else {
		return nil, fmt.Errorf("failed to get deployment: %w", err)
	}

	// Get service
	svc, err := s.k8sClient.GetService(ctx, id, namespace)
	if err != nil {
		if errors.IsNotFound(err) {
			return nil, fmt.Errorf("MCP server service not found: %s", id)
		}
		return nil, fmt.Errorf("failed to get service: %w", err)
	}

	// Extract metadata from labels
	clientID := pod.Labels["apa.io/client-id"]
	mcpType := pod.Labels["apa.io/mcp-type"]

	// Determine status
	statusStr, message := kubernetes.GetPodStatus(pod)
	status := models.MCPServerStatusPending
	switch statusStr {
	case "running":
		status = models.MCPServerStatusRunning
	case "failed":
		status = models.MCPServerStatusFailed
	case "terminating":
		status = models.MCPServerStatusTerminating
	}

	// Build URL
	port := int(svc.Spec.Ports[0].Port)
	url := kubernetes.GetServiceURL(id, namespace, port)

	return &models.MCPServer{
		ID:        id,
		ClientID:  clientID,
		MCPType:   mcpType,
		URL:       url,
		Status:    status,
		CreatedAt: createdAt,
		Message:   message,
	}, nil
}

// ListAvailableTypes returns the list of configured MCP server types
func (s *mcpService) ListAvailableTypes() []string {
	return s.config.ListMCPServerTypes()
}

// checkExistingServer checks if a server already exists and is healthy
func (s *mcpService) checkExistingServer(ctx context.Context, name, namespace string) (*models.MCPServer, error) {
	// Try to get the existing server
	server, err := s.GetServer(ctx, name)
	if err != nil {
		return nil, err
	}

	// Check if it's healthy
	if server.Status == models.MCPServerStatusRunning || server.Status == models.MCPServerStatusPending {
		return server, nil
	}

	return server, fmt.Errorf("server exists but is not healthy: %s", server.Status)
}

// cleanup removes deployment/job and service
func (s *mcpService) cleanup(ctx context.Context, name, namespace string) error {
	// Delete service first
	if err := s.k8sClient.DeleteService(ctx, name, namespace); err != nil {
		if !errors.IsNotFound(err) {
			s.logger.ErrorContext(ctx, "Failed to delete service",
				slog.String("name", name),
				slog.String("error", err.Error()))
		}
	}

	// Try to delete deployment first
	if err := s.k8sClient.DeleteDeployment(ctx, name, namespace); err != nil {
		if errors.IsNotFound(err) {
			// Not a deployment, try job
			if err := s.k8sClient.DeleteJob(ctx, name, namespace); err != nil {
				if !errors.IsNotFound(err) {
					return fmt.Errorf("failed to delete job: %w", err)
				}
			}
		} else {
			return fmt.Errorf("failed to delete deployment: %w", err)
		}
	}

	return nil
}

// waitForReady waits briefly for the pod to become ready
func (s *mcpService) waitForReady(ctx context.Context, name, namespace string, server *models.MCPServer) *models.MCPServer {
	// Create a context with timeout
	waitCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-waitCtx.Done():
			// Timeout reached, return pending status
			return nil
		case <-ticker.C:
			// Check pod status - find pods by label
			pods, err := s.k8sClient.ListPods(waitCtx, namespace, map[string]string{"apa.io/mcp-server-id": name})
			if err != nil || len(pods) == 0 {
				continue
			}
			pod := pods[0]

			statusStr, message := kubernetes.GetPodStatus(pod)
			if statusStr == "running" {
				server.Status = models.MCPServerStatusRunning
				server.Message = message
				return server
			} else if statusStr == "failed" {
				server.Status = models.MCPServerStatusFailed
				server.Message = message
				return server
			}
		}
	}
}

// StopServersByClient stops all MCP servers for a client
func (s *mcpService) StopServersByClient(ctx context.Context, clientID string, mcpType string) error {

	// Check if k8sClient is available for dynamic servers
	if s.k8sClient == nil {
		s.logger.WarnContext(ctx, "Kubernetes client not available - cannot stop dynamic MCP servers",
			slog.String("client_id", clientID),
			slog.String("mcp_type", mcpType))
		return nil
	}

	namespace := s.config.Kubernetes.Namespace

	// Build label selector
	labels := map[string]string{
		"apa.io/client-id": clientID,
	}
	if mcpType != "" {
		labels["apa.io/mcp-type"] = mcpType
	}

	s.logger.InfoContext(ctx, "Stopping MCP servers by client",
		slog.String("client_id", clientID),
		slog.String("mcp_type", mcpType))

	// Count of servers deleted
	serversDeleted := 0

	// List and delete deployments with the labels
	deployments, err := s.k8sClient.ListDeployments(ctx, namespace, labels)
	if err != nil {
		return fmt.Errorf("failed to list deployments: %w", err)
	}

	for _, deployment := range deployments {
		name := deployment.Name
		s.logger.InfoContext(ctx, "Deleting MCP server deployment",
			slog.String("name", name))

		// Delete service first
		if err := s.k8sClient.DeleteService(ctx, name, namespace); err != nil {
			if !errors.IsNotFound(err) {
				s.logger.ErrorContext(ctx, "Failed to delete service",
					slog.String("name", name),
					slog.String("error", err.Error()))
			}
		}

		// Delete deployment
		if err := s.k8sClient.DeleteDeployment(ctx, name, namespace); err != nil {
			if !errors.IsNotFound(err) {
				s.logger.ErrorContext(ctx, "Failed to delete deployment",
					slog.String("name", name),
					slog.String("error", err.Error()))
				// Continue with other deployments
			}
		}
		serversDeleted++
	}

	// List and delete jobs with the labels
	jobs, err := s.k8sClient.ListJobs(ctx, namespace, labels)
	if err != nil {
		return fmt.Errorf("failed to list jobs: %w", err)
	}

	for _, job := range jobs {
		name := job.Name
		s.logger.InfoContext(ctx, "Deleting MCP server job",
			slog.String("name", name))

		// Delete service first
		if err := s.k8sClient.DeleteService(ctx, name, namespace); err != nil {
			if !errors.IsNotFound(err) {
				s.logger.ErrorContext(ctx, "Failed to delete service",
					slog.String("name", name),
					slog.String("error", err.Error()))
			}
		}

		// Delete job
		if err := s.k8sClient.DeleteJob(ctx, name, namespace); err != nil {
			if !errors.IsNotFound(err) {
				s.logger.ErrorContext(ctx, "Failed to delete job",
					slog.String("name", name),
					slog.String("error", err.Error()))
				// Continue with other jobs
			}
		}
		serversDeleted++
	}

	// No error if no servers found - it's effectively a no-op
	return nil
}

// isStaticServer checks if the server ID indicates a static server
func isStaticServer(id string) bool {
	return strings.HasPrefix(id, staticServerPrefix)
}
