{"path":"Extras/Images/Pasted image 20230121173420 1.png","text":"function PL-FC-ENTAILS?(KB, g) returns frue or false inputs: KB, the knowledge base, a set of propositional definite clauses g, the query, a proposition symbol count +— a table, where count[c] is initially the number of symbols in clause ¢’s premise inferred < a table, where inferred|s] is initially false for all symbols queue < a queue of symbols, initially symbols known to be true in KB while gueue is not empty do p < PopP(queue) if p = g then return rrue if inferred[p] = false then inferred|p] < true for each clause ¢ in KB where p is in c.PREMISE do decrement count[c] if count[c] = 0 then add c. CONCLUSION to queue return false Figure 7.15 The forward-chaining algorithm for propositional logic. The agenda keeps track of symbols known to be true but not yet “processed.” The count table keeps track of how many premises of each implication are not yet proven. Whenever a new symbol p from the agenda is processed, the count is reduced by one for each implication in whose premise p appears (easily identified in constant time with appropriate indexing.) If a count reaches zero, all the premises of the implication are known, so its conclusion can be added to the agenda. Finally, we need to keep track of which symbols have been processed; a symbol that is already in the set of inferred symbols need not be added to the agenda again. This avoids redundant work and prevents loops caused by implications such as P = Q and Q = P.","libVersion":"0.5.0","langs":"eng"}