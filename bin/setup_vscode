#!/usr/bin/env bash
#
# VS Code dotfiles setup script
#
# Author: mbastakis
# Last updated: $(date '+%Y-%m-%d')
#

set -euo pipefail
IFS=$'\n\t'

# Get script directory and source utils
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOTFILES_ROOT="$(dirname "$SCRIPT_DIR")"
source "$DOTFILES_ROOT/scripts/utils.sh"

# Initialize utils
init_utils

# VS Code configuration paths
get_vscode_user_dir() {
    case "$OSTYPE" in
        darwin*)
            echo "$HOME/Library/Application Support/Code/User"
            ;;
        linux-gnu*)
            echo "$HOME/.config/Code/User"
            ;;
        msys|win32)
            echo "$APPDATA/Code/User"
            ;;
        *)
            die "Unsupported operating system: $OSTYPE"
            ;;
    esac
}

VSCODE_USER_DIR="$(get_vscode_user_dir)"
DOTFILES_VSCODE_DIR="$DOTFILES_ROOT/vscode"

# Main function
main() {
    local action=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            setup|link)
                action="setup"
                shift
                ;;
            sync)
                action="sync"
                shift
                ;;
            extensions)
                action="extensions"
                shift
                break  # Let extensions subcommand handle remaining args
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -y|--yes)
                FORCE_YES=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --force-reinstall)
                FORCE_REINSTALL=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Default action
    if [ -z "$action" ]; then
        action="setup"
    fi
    
    log_section "VS Code Configuration Management"
    
    # Validate VS Code directory exists
    if [ ! -d "$DOTFILES_VSCODE_DIR" ]; then
        die "Dotfiles VS Code directory not found: $DOTFILES_VSCODE_DIR"
    fi
    
    # Execute action
    case "$action" in
        "setup")
            setup_vscode_dotfiles
            ;;
        "sync")
            sync_from_vscode
            setup_vscode_dotfiles
            ;;
        "extensions")
            handle_extensions "$@"
            ;;
        *)
            log_error "Unknown action: $action"
            exit 1
            ;;
    esac
    
    log_section "VS Code Configuration Complete"
}

# Setup VS Code dotfiles
setup_vscode_dotfiles() {
    log_subsection "Setting up VS Code dotfiles"
    
    # Create symlinks for configuration files
    create_vscode_symlink "settings.json"
    create_vscode_symlink "keybindings.json"
    
    # Handle snippets directory if it exists
    if [ -d "$DOTFILES_VSCODE_DIR/snippets" ]; then
        create_vscode_symlink "snippets" "directory"
    fi
    
    # Setup TUI Manager extension
    setup_tui_manager_extension
    
    log_success "VS Code dotfiles setup completed"
}

# Create VS Code symlink
create_vscode_symlink() {
    local file="$1"
    local type="${2:-file}"
    local source="$DOTFILES_VSCODE_DIR/$file"
    local target="$VSCODE_USER_DIR/$file"
    
    log_info "Setting up $file $type"
    
    if [[ "$DRY_RUN" != "true" ]]; then
        # Create VS Code User directory if it doesn't exist
        ensure_dir "$(dirname "$target")"
        
        # Backup existing file if it exists and is not a symlink
        if [ -f "$target" ] && [ ! -L "$target" ]; then
            backup_file "$target"
        fi
        
        # Remove existing file/symlink
        if [ -e "$target" ] || [ -L "$target" ]; then
            rm "$target"
        fi
        
        # Create symlink
        ln -sf "$source" "$target"
        log_success "$file symlink created: $target -> $source"
    else
        log_info "[DRY RUN] Would create symlink: $target -> $source"
    fi
}

# Sync from current VS Code config to dotfiles
sync_from_vscode() {
    log_subsection "Syncing from VS Code to dotfiles"
    
    # Copy current VS Code settings to dotfiles if they exist and are not symlinks
    sync_vscode_file "settings.json"
    sync_vscode_file "keybindings.json"
    
    # Update extensions list
    sync_vscode_extensions
}

# Sync individual VS Code file
sync_vscode_file() {
    local file="$1"
    local source="$VSCODE_USER_DIR/$file"
    local target="$DOTFILES_VSCODE_DIR/$file"
    
    if [ -f "$source" ] && [ ! -L "$source" ]; then
        log_info "Copying $file to dotfiles"
        if [[ "$DRY_RUN" != "true" ]]; then
            cp "$source" "$target"
            log_success "$file copied to dotfiles"
        else
            log_info "[DRY RUN] Would copy $file to dotfiles"
        fi
    fi
}

# Handle extensions subcommand
handle_extensions() {
    local subaction=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            install)
                subaction="install"
                shift
                ;;
            update|sync)
                subaction="update"
                shift
                ;;
            list)
                subaction="list"
                shift
                ;;
            --force-reinstall)
                FORCE_REINSTALL=true
                shift
                ;;
            *)
                log_error "Unknown extensions subcommand: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    if [ -z "$subaction" ]; then
        log_error "Extensions subcommand required"
        show_help
        exit 1
    fi
    
    case "$subaction" in
        "install")
            install_vscode_extensions
            ;;
        "update")
            sync_vscode_extensions
            ;;
        "list")
            list_vscode_extensions
            ;;
    esac
}

# List VS Code extensions
list_vscode_extensions() {
    local extensions_file="$DOTFILES_VSCODE_DIR/extensions.txt"
    
    if [ -f "$extensions_file" ]; then
        log_subsection "VS Code Extensions in dotfiles"
        cat "$extensions_file"
    else
        log_warning "Extensions file not found: $extensions_file"
    fi
    
    if command_exists code; then
        log_subsection "Currently Installed Extensions"
        code --list-extensions
    else
        log_warning "VS Code CLI not available"
    fi
}

# Help function
show_help() {
    cat << EOF
VS Code Configuration Management Script

Usage: $0 [ACTION] [OPTIONS]

Actions:
    setup, link           Create symlinks from dotfiles to VS Code config (default)
    sync                 Copy current VS Code config to dotfiles, then setup symlinks
    extensions SUBACTION Handle VS Code extensions

Extension Subactions:
    install              Install all extensions from extensions.txt
    update, sync         Update extensions.txt with currently installed extensions
    list                 List extensions in dotfiles and currently installed

Options:
    -v, --verbose        Enable verbose output
    -y, --yes           Answer yes to all prompts
    --dry-run           Show what would be done without executing
    --force-reinstall   Reinstall all extensions even if already installed
    -h, --help          Show this help message

Examples:
    $0                           # Setup VS Code dotfiles
    $0 sync                      # Sync current config to dotfiles
    $0 extensions install        # Install extensions from list
    $0 extensions update         # Update extensions list
    $0 --dry-run                 # Preview operations

Paths:
    VS Code config: $VSCODE_USER_DIR
    Dotfiles:       $DOTFILES_VSCODE_DIR
EOF
}

# Sync VS Code extensions to dotfiles (marketplace extensions only)
sync_vscode_extensions() {
    local extensions_file="$DOTFILES_VSCODE_DIR/extensions.txt"
    
    log_info "Syncing VS Code extensions to dotfiles"
    
    if command_exists code; then
        if [[ "$DRY_RUN" != "true" ]]; then
            # Export only marketplace extensions (exclude local extensions starting with "local.")
            code --list-extensions | grep -v "^local\." > "$extensions_file"
            log_success "Extensions list updated: $extensions_file"
            
            # Show summary
            local count
            count=$(wc -l < "$extensions_file" | tr -d ' ')
            log_info "Exported $count marketplace extensions"
        else
            log_info "[DRY RUN] Would sync extensions to $extensions_file"
        fi
    else
        log_error "VS Code CLI not available"
        return 1
    fi
}

# Check if a VS Code extension is installed
is_extension_installed() {
    local extension_id="$1"
    
    if ! command_exists code; then
        return 1
    fi
    
    code --list-extensions | grep -q "^${extension_id}$"
}

# Get installed extension version (returns empty if not installed)
get_extension_version() {
    local extension_id="$1"
    
    if ! command_exists code; then
        return 1
    fi
    
    # VS Code doesn't provide version info via CLI easily, so we just check if installed
    if is_extension_installed "$extension_id"; then
        echo "installed"
    else
        echo ""
    fi
}

# Check if TUI Manager extension is installed
is_tui_manager_installed() {
    if is_extension_installed "local.tui-manager"; then
        return 0
    elif code --list-extensions | grep -q "tui-manager"; then
        return 0
    else
        return 1
    fi
}

# Install VS Code extensions from dotfiles
install_vscode_extensions() {
    local extensions_file="$DOTFILES_VSCODE_DIR/extensions.txt"
    
    log_info "Installing VS Code extensions from dotfiles"
    
    if [ ! -f "$extensions_file" ]; then
        log_warning "Extensions file not found: $extensions_file"
        log_info "Run 'sync_vscode_extensions' first to create the file"
        return 1
    fi
    
    if ! command_exists code; then
        log_error "VS Code CLI not available"
        return 1
    fi
    
    # Install marketplace extensions from file
    local installed_count=0
    local skipped_count=0
    local failed_count=0
    local force_reinstall=false
    
    # Check for force reinstall flag
    if [[ "${FORCE_REINSTALL:-}" == "true" ]]; then
        force_reinstall=true
        log_info "Force reinstall mode enabled - will reinstall all extensions"
    fi
    
    # Count total extensions for progress reporting
    local total_extensions
    total_extensions=$(grep -v "^#" "$extensions_file" | grep -v "^$" | wc -l | tr -d ' ')
    local current_extension=0
    
    log_info "Processing $total_extensions extensions..."
    
    while IFS= read -r extension || [[ -n "$extension" ]]; do
        # Skip empty lines and comments
        if [[ -z "$extension" || "$extension" =~ ^[[:space:]]*# ]]; then
            continue
        fi
        
        ((current_extension++))
        
        # Check if extension is already installed
        if [[ "$force_reinstall" == "false" ]] && is_extension_installed "$extension"; then
            log_info "[$current_extension/$total_extensions] Already installed: $extension"
            ((skipped_count++))
            continue
        fi
        
        log_info "[$current_extension/$total_extensions] Installing: $extension"
        
        if [[ "$DRY_RUN" != "true" ]]; then
            if code --install-extension "$extension" --force >/dev/null 2>&1; then
                ((installed_count++))
                log_success "[$current_extension/$total_extensions] Installed: $extension"
            else
                ((failed_count++))
                log_error "[$current_extension/$total_extensions] Failed: $extension"
            fi
        else
            log_info "[$current_extension/$total_extensions] [DRY RUN] Would install: $extension"
            ((installed_count++))
        fi
    done < "$extensions_file"
    
    # Install local extensions separately
    setup_tui_manager_extension
    
    if [[ "$DRY_RUN" != "true" ]]; then
        log_success "Extension installation complete"
        log_info "Summary: $installed_count newly installed, $skipped_count already installed, $failed_count failed"
        
        if [ "$failed_count" -gt 0 ]; then
            log_warning "Some extensions failed to install. Check the output above for details."
        fi
    else
        log_info "Summary: Would install $installed_count extensions, $skipped_count already installed"
    fi
}

# Setup TUI Manager extension using VSIX packaging
setup_tui_manager_extension() {
    local extension_dir="$DOTFILES_VSCODE_DIR/extensions/tui-manager"
    local vsix_file="$extension_dir/tui-manager.vsix"
    local needs_rebuild=false
    
    log_info "Setting up TUI Manager extension"
    
    # Check if extension directory exists
    if [ ! -d "$extension_dir" ]; then
        log_error "TUI Manager extension directory not found: $extension_dir"
        return 1
    fi
    
    # Check if TUI Manager is already installed and up-to-date
    if is_tui_manager_installed && [ -f "$vsix_file" ]; then
        log_info "TUI Manager extension already installed"
        
        # Check if source files are newer than VSIX
        if [ "$extension_dir/src" -nt "$vsix_file" ] || [ "$extension_dir/package.json" -nt "$vsix_file" ]; then
            log_info "Source files are newer than installed version, rebuilding..."
            needs_rebuild=true
        else
            log_info "TUI Manager extension is up-to-date, skipping rebuild"
            return 0
        fi
    else
        log_info "TUI Manager extension not installed or VSIX missing, building..."
        needs_rebuild=true
    fi
    
    if [[ "$DRY_RUN" != "true" ]]; then
        if [[ "$needs_rebuild" == "true" ]]; then
            # Compile the extension first
            if [ -f "$extension_dir/tsconfig.json" ]; then
                log_info "Compiling TUI Manager extension"
                if command_exists npm; then
                    (cd "$extension_dir" && npm run compile 2>/dev/null || log_warning "Failed to compile extension")
                else
                    log_warning "npm not available, extension may need manual compilation"
                fi
            fi
            
            # Package the extension into VSIX
            log_info "Packaging TUI Manager extension"
            if command_exists vsce; then
                (cd "$extension_dir" && vsce package --out tui-manager.vsix --no-yarn 2>/dev/null || log_warning "Failed to package extension")
            else
                log_error "vsce not available, cannot package extension"
                log_info "Install vsce with: npm install -g @vscode/vsce"
                return 1
            fi
        fi
        
        # Install the VSIX file if it exists and we need to install
        if [ -f "$vsix_file" ] && ([[ "$needs_rebuild" == "true" ]] || ! is_tui_manager_installed); then
            log_info "Installing TUI Manager extension from VSIX"
            if command_exists code; then
                if code --install-extension "$vsix_file" --force; then
                    log_success "TUI Manager extension installed successfully"
                    log_info "Please reload VS Code for the extension to take effect"
                else
                    log_error "Failed to install TUI Manager extension"
                    return 1
                fi
            else
                log_error "VS Code CLI not available"
                return 1
            fi
        elif [ ! -f "$vsix_file" ]; then
            log_error "VSIX file not found: $vsix_file"
            return 1
        fi
    else
        if [[ "$needs_rebuild" == "true" ]]; then
            log_info "[DRY RUN] Would package and install TUI Manager extension"
        else
            log_info "[DRY RUN] TUI Manager extension is up-to-date"
        fi
    fi
}

# Run main function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
