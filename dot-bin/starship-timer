#!/usr/bin/env bash
# starship-timer - Set/clear timers for Starship prompt display
# Usage:
#   starship-timer set <name> <expiration>   - Set a timer
#   starship-timer clear <name>              - Clear a timer
#   starship-timer list                      - List active timers
#
# Expiration can be:
#   - Unix epoch timestamp (e.g., 1704067200)
#   - Duration string (e.g., 12h, 30m, 1h30m, 2h15m)

set -euo pipefail

TIMER_DIR="${HOME}/.cache/starship-timers"

usage() {
    cat >&2 <<EOF
Usage: starship-timer <command> [args]

Commands:
    set <name> <expiration>   Set a timer (epoch or duration like 12h, 30m, 1h30m)
    clear <name>              Clear a timer
    list                      List all active timers

Examples:
    starship-timer set aws-session 1704067200
    starship-timer set aws-session 12h
    starship-timer set vpn 1h30m
    starship-timer clear aws-session
EOF
    exit 1
}

# Parse duration string (e.g., "12h", "30m", "1h30m") to seconds
parse_duration() {
    local duration="$1"
    local total_seconds=0
    
    # Extract hours if present
    if [[ "$duration" =~ ([0-9]+)h ]]; then
        total_seconds=$((total_seconds + ${BASH_REMATCH[1]} * 3600))
    fi
    
    # Extract minutes if present
    if [[ "$duration" =~ ([0-9]+)m ]]; then
        total_seconds=$((total_seconds + ${BASH_REMATCH[1]} * 60))
    fi
    
    # Extract seconds if present
    if [[ "$duration" =~ ([0-9]+)s ]]; then
        total_seconds=$((total_seconds + ${BASH_REMATCH[1]}))
    fi
    
    # If no units matched, check if it's just a number (treat as seconds)
    if [[ $total_seconds -eq 0 ]] && [[ "$duration" =~ ^[0-9]+$ ]]; then
        total_seconds="$duration"
    fi
    
    echo "$total_seconds"
}

# Check if value looks like an epoch timestamp (10+ digits, reasonable range)
is_epoch() {
    local value="$1"
    # Must be all digits and at least 10 chars (epoch timestamps are 10 digits)
    if [[ "$value" =~ ^[0-9]{10,}$ ]]; then
        # Sanity check: should be after year 2000 and before year 2100
        if [[ "$value" -ge 946684800 ]] && [[ "$value" -le 4102444800 ]]; then
            return 0
        fi
    fi
    return 1
}

# Clean up any expired timer files
cleanup_expired() {
    [[ -d "$TIMER_DIR" ]] || return 0
    local now timer_file expiration
    now=$(date +%s)
    for timer_file in "$TIMER_DIR"/*; do
        [[ -f "$timer_file" ]] || continue
        expiration=$(cat "$timer_file")
        if [[ $((expiration - now)) -le 0 ]]; then
            rm -f "$timer_file"
        fi
    done
}

cmd_set() {
    local name="${1:-}"
    local value="${2:-}"
    
    if [[ -z "$name" ]] || [[ -z "$value" ]]; then
        echo "Error: set requires <name> and <expiration>" >&2
        usage
    fi
    
    mkdir -p "$TIMER_DIR"
    cleanup_expired  # Prune expired timers opportunistically
    
    local expiration_epoch
    
    if is_epoch "$value"; then
        # Value is already an epoch timestamp
        expiration_epoch="$value"
    else
        # Parse as duration and add to current time
        local duration_seconds
        duration_seconds=$(parse_duration "$value")
        
        if [[ "$duration_seconds" -eq 0 ]]; then
            echo "Error: Invalid duration format '$value'" >&2
            echo "Use formats like: 12h, 30m, 1h30m, 2h15m" >&2
            exit 1
        fi
        
        expiration_epoch=$(($(date +%s) + duration_seconds))
    fi
    
    echo "$expiration_epoch" > "$TIMER_DIR/$name"
    
    # Calculate and display remaining time for confirmation
    local now remaining hours minutes
    now=$(date +%s)
    remaining=$((expiration_epoch - now))
    hours=$((remaining / 3600))
    minutes=$(((remaining % 3600) / 60))
    
    if [[ $hours -gt 0 ]]; then
        echo "Timer '$name' set: ${hours}h ${minutes}m remaining"
    else
        echo "Timer '$name' set: ${minutes}m remaining"
    fi
}

cmd_clear() {
    local name="${1:-}"
    
    if [[ -z "$name" ]]; then
        echo "Error: clear requires <name>" >&2
        usage
    fi
    
    if [[ -f "$TIMER_DIR/$name" ]]; then
        rm -f "$TIMER_DIR/$name"
        echo "Timer '$name' cleared"
    else
        echo "Timer '$name' not found"
    fi
}

cmd_list() {
    if [[ ! -d "$TIMER_DIR" ]]; then
        echo "No timers set"
        return
    fi
    
    local now found=0
    now=$(date +%s)
    
    for timer_file in "$TIMER_DIR"/*; do
        [[ -f "$timer_file" ]] || continue
        found=1
        
        local name expiration remaining
        name=$(basename "$timer_file")
        expiration=$(cat "$timer_file")
        remaining=$((expiration - now))
        
        if [[ $remaining -le 0 ]]; then
            rm -f "$timer_file"  # Clean up expired timer
            echo "$name: EXPIRED (cleaned up)"
        else
            local hours minutes
            hours=$((remaining / 3600))
            minutes=$(((remaining % 3600) / 60))
            
            if [[ $hours -gt 0 ]]; then
                echo "$name: ${hours}h ${minutes}m remaining"
            else
                echo "$name: ${minutes}m remaining"
            fi
        fi
    done
    
    if [[ $found -eq 0 ]]; then
        echo "No timers set"
    fi
}

# Main
case "${1:-}" in
    set)
        shift
        cmd_set "$@"
        ;;
    clear)
        shift
        cmd_clear "$@"
        ;;
    list)
        cmd_list
        ;;
    -h|--help)
        usage
        ;;
    *)
        usage
        ;;
esac
